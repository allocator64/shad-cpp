а)
a = b + c * d << 2 & 8

Этот ужас эквиалентен вот этому ужасу:

a = ((b + (c * d)) << 2) & 8;

типы - любые, для которых определены соотв. операторы
тип результа - тип соответствующего оператора &


А все потому, что после упрорядовачения по приоритетам получаем:
*
+
<<
&

б)
a & 077 |= 3

Некорректно, потому что результат вычисления (a & 077) не является lvalue

в)
a == b || a == c && c < 5

Соответствует

((a == b) || ((a == c) && (c < 5)))

По приоритету операции:
<
==
&&
||

резуьтат булевый, типы любые с соотв. операторами

г)

c = x != 0

c = (x != 0)

Приоритеты:
!=
=

Тип с - булевый, для x должен быть определен != c чем-то типа инта

д)

0 <= I < 7
(0 <= I) < 7
((0 <= I) ? 1 : 0) < 7

Потому что <= и < имеют равный приоритер, а вычисление слева направо
Булева скобка приведется к int (либо к 1 в случае истины, либо к нулю)

е)

1,2 + 3
(1), (2 + 3)

у оператора запятая наименьший приоритет из всех

примеры использования
        return 1, 2+3;
        return 2+3;

    auto actual = [](int *a) {
        return *a = 1, 2+3;
    };

    auto expected = [](int *a) {
        *a = 1;
        return 2+3;
    };

ж)
a=-1++b--5

Некорректно.
Впервом приоритете постфиксные, потом инфиксные.
Но инфиксные применимы только к lvalue
(это первая ошибка, на чем завалиться компиляция)

з)

a = - 1 + + b - - 5
a = -1 + b + 5
a = b + 4

a = (((- 1) + (+ b)) - (- 5))

У унарной операции приорит больше, чем у бинарной

и)

a = b == c++
a = (b == c++)

что тоже самое, что

        a = (b == c);
        c++;

Для сохранения результата посл строчки -

        c++;
        a = (b == (c - 1));

к)
a = b = c = 0

Все ок, результат присваивание - выражение которое присвоили
эквивалентно
a = 0;
b = 0;
c = 0;

л)

a[4][2] *=* b ? c : *d*2
a[4][2] *= ((*b) ? (c) : ((*d) * 2))

возможные типы
int a[n][n];
int *b;
int c;
int *d;

Приоритеты

Разыменование
Умножение
Тернарный оператор

м)

a - b, c = d
(a - b), (c = d)

Приоритет запятой минимален

строка
return x = a - b, c = d
эквивалентна
x = (a - b);
c = d;
return d;

н)

*p++

*(p++)

++p
*(p - 1)

приоритет постфиксного ++ больше, но вернет старое значение

*--p
*(--p)

--p;
*p

Префиксный возвращает после декремента

п)
++++a--

см пункт ж

Приортет больше у постфиксного, а инфиксный нельзя применить к rvalue
некорректно.

р)
(-++++a)--
(-(++(++a)))--

Тут ++ префиксные, возвращают lvalue, но после унарного минуса появляется rvalue, к которому нельзя применить --
Некорректно.

с)
++a--
++(a--)

Тож самое. Некорректно.
Потому что префиксный ++ нельзя применить к результату постфиксного (большего в приоритете) --, ибо тот rvalue

т)

(int*)p->m
(int *)(p->m)

Приоритет -> больше, чем C-style type-casting

у)

*p.m
*(p.m)

Приоритет доступа по "."" больше, чем разыменования

ф)

*a[i]
*(a[i])

Приоритет кв. скобок больше разыменования